import * as tslib_1 from "tslib";
import { AfterViewInit, ChangeDetectionStrategy, Component, ElementRef, EventEmitter, Input, NgZone, OnChanges, Output, ViewChild, } from '@angular/core';
var ChartjsComponent = /** @class */ (function () {
    function ChartjsComponent(zone) {
        this.zone = zone;
        this.chartClick = new EventEmitter();
        /** chart type */
        this.type = 'doughnut';
        this.height = 150;
        this.width = 300;
        this.legend = {
            display: true,
            position: 'bottom',
        };
        this.options = {};
        this.redraw = false;
        this.datasetKeyProvider = function (d) { return d.label; };
    }
    ChartjsComponent.prototype.ngAfterViewInit = function () {
        this.renderChart();
    };
    ChartjsComponent.prototype.ngOnChanges = function (changes) {
        if (changes.firstChange) {
            return;
        }
        if (this.chartInstance && this.redraw) {
            this.chartInstance.destroy();
            this.renderChart();
            return;
        }
        this.updateChart();
    };
    ChartjsComponent.prototype.updateChart = function () {
        var _this = this;
        var data = this.transformData();
        if (!this.chartInstance) {
            return;
        }
        if (this.options) {
            // in order to allow for universal rendering, we import chart.js runtime with `require` to prevent node errors
            var Chart_1 = require('chart.js');
            this.chartInstance.options = Chart_1.helpers.configMerge(this.chartInstance.options, this.options);
        }
        // Pipe datasets to chart instance datasets enabling
        // seamless transitions
        var currentDatasets = (this.chartInstance.config.data &&
            this.chartInstance.config.data.datasets) ||
            [];
        var nextDatasets = data.datasets || [];
        var currentDatasetsIndexed = {};
        currentDatasets.forEach(function (x) {
            currentDatasetsIndexed[_this.datasetKeyProvider(x)] = x;
        });
        // We can safely replace the dataset array, as long as we retain the _meta property
        // on each dataset.
        this.chartInstance.config.data.datasets = nextDatasets.map(function (next) {
            var e_1, _a, e_2, _b;
            var current = currentDatasetsIndexed[_this.datasetKeyProvider(next)];
            if (current && current.type === next.type) {
                try {
                    // Reassign all properties from next
                    for (var _c = tslib_1.__values(Object.keys(next)), _d = _c.next(); !_d.done; _d = _c.next()) {
                        var nextProp = _d.value;
                        // Data array can't be reassigned here.
                        if (nextProp !== 'data') {
                            current[nextProp] = next[nextProp];
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                try {
                    // Remove properties from current if they was removed in next
                    for (var _e = tslib_1.__values(Object.keys(current)), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var currentProp = _f.value;
                        // Be careful with _meta property
                        if (!next.hasOwnProperty(currentProp) && currentProp !== '_meta') {
                            delete current[currentProp];
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
                // The data array must be edited in place. As chart.js adds listeners to it.
                current.data.splice(next.data.length);
                next.data.forEach(function (point, pid) {
                    current.data[pid] = next.data[pid];
                });
                return current;
            }
            return next;
        });
        var datasets = data.datasets, rest = tslib_1.__rest(data, ["datasets"]);
        this.chartInstance.config.data = tslib_1.__assign({}, this.chartInstance.config.data, rest);
        this.chartInstance.update();
    };
    ChartjsComponent.prototype.renderChart = function () {
        var _this = this;
        var node = this.ref.nativeElement;
        var data = this.transformData();
        if (typeof this.legend !== 'undefined') {
            var legendOptions = tslib_1.__assign({}, this.legend, this.options.legend);
            this.options.legend = legendOptions;
        }
        // in order to allow for universal rendering, we import Codemirror runtime with `require` to prevent node errors
        var Chart = require('chart.js');
        this.zone.runOutsideAngular(function () {
            _this.chartInstance = new Chart(node, {
                type: _this.type,
                data: data,
                options: _this.options,
                plugins: _this.plugins,
            });
        });
    };
    ChartjsComponent.prototype.transformData = function () {
        if (!this.data) {
            return;
        }
        if (typeof this.data === 'function') {
            var node = this.ref;
            return this.data(node);
        }
        return this.data;
    };
    ChartjsComponent.prototype.handleOnClick = function ($event) {
        this.chartClick.emit({
            elements: this.chartInstance.getElementsAtEvent($event),
            element: this.chartInstance.getElementAtEvent($event),
            dataset: this.chartInstance.getDatasetAtEvent($event),
            $event: $event,
        });
    };
    ChartjsComponent.ctorParameters = function () { return [
        { type: NgZone }
    ]; };
    tslib_1.__decorate([
        ViewChild('ref', { static: true }),
        tslib_1.__metadata("design:type", ElementRef)
    ], ChartjsComponent.prototype, "ref", void 0);
    tslib_1.__decorate([
        Output(),
        tslib_1.__metadata("design:type", Object)
    ], ChartjsComponent.prototype, "chartClick", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String)
    ], ChartjsComponent.prototype, "type", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Object)
    ], ChartjsComponent.prototype, "data", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Object)
    ], ChartjsComponent.prototype, "height", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Object)
    ], ChartjsComponent.prototype, "width", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Object)
    ], ChartjsComponent.prototype, "legend", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Object)
    ], ChartjsComponent.prototype, "options", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Array)
    ], ChartjsComponent.prototype, "plugins", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Object)
    ], ChartjsComponent.prototype, "redraw", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Function)
    ], ChartjsComponent.prototype, "datasetKeyProvider", void 0);
    ChartjsComponent = tslib_1.__decorate([
        Component({
            selector: 'ngx-chartjs',
            template: "\n  <!-- wrapping div required for height, width to work -->\n  <div>\n    <canvas\n      #ref\n      [attr.height]=\"height\"\n      [attr.width]=\"width\"\n      (click)=\"handleOnClick($event)\"\n    ></canvas>\n  </div>\n  ",
            changeDetection: ChangeDetectionStrategy.OnPush
        }),
        tslib_1.__metadata("design:paramtypes", [NgZone])
    ], ChartjsComponent);
    return ChartjsComponent;
}());
export { ChartjsComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hhcnRqcy5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AY3RybC9uZ3gtY2hhcnRqcy8iLCJzb3VyY2VzIjpbImNoYXJ0anMuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQ0wsYUFBYSxFQUNiLHVCQUF1QixFQUN2QixTQUFTLEVBQ1QsVUFBVSxFQUNWLFlBQVksRUFDWixLQUFLLEVBQ0wsTUFBTSxFQUNOLFNBQVMsRUFDVCxNQUFNLEVBQ04sU0FBUyxHQUNWLE1BQU0sZUFBZSxDQUFDO0FBeUJ2QjtJQW1CRSwwQkFBb0IsSUFBWTtRQUFaLFNBQUksR0FBSixJQUFJLENBQVE7UUFoQnRCLGVBQVUsR0FBRyxJQUFJLFlBQVksRUFBbUIsQ0FBQztRQUMzRCxpQkFBaUI7UUFDUixTQUFJLEdBQXVCLFVBQVUsQ0FBQztRQUV0QyxXQUFNLEdBQUcsR0FBRyxDQUFDO1FBQ2IsVUFBSyxHQUFHLEdBQUcsQ0FBQztRQUVyQixXQUFNLEdBQTZCO1lBQ2pDLE9BQU8sRUFBRSxJQUFJO1lBQ2IsUUFBUSxFQUFFLFFBQVE7U0FDbkIsQ0FBQztRQUNPLFlBQU8sR0FBdUIsRUFBRSxDQUFDO1FBRWpDLFdBQU0sR0FBRyxLQUFLLENBQUM7UUFDZix1QkFBa0IsR0FBdUIsVUFBQSxDQUFDLElBQUksT0FBQSxDQUFDLENBQUMsS0FBSyxFQUFQLENBQU8sQ0FBQztJQUU1QixDQUFDO0lBRXBDLDBDQUFlLEdBQWY7UUFDRSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDckIsQ0FBQztJQUNELHNDQUFXLEdBQVgsVUFBWSxPQUFZO1FBQ3RCLElBQUksT0FBTyxDQUFDLFdBQVcsRUFBRTtZQUN2QixPQUFPO1NBQ1I7UUFDRCxJQUFJLElBQUksQ0FBQyxhQUFhLElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUNyQyxJQUFJLENBQUMsYUFBYSxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQzdCLElBQUksQ0FBQyxXQUFXLEVBQUUs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LHVCQUF1QixDQUFDLE1BQU07U0FDaEQsQ0FBQztpREFvQjBCLE1BQU07T0FuQnJCLGdCQUFnQixDQW1KNUI7SUFBRCx1QkFBQztDQUFBLEFBbkpELElBbUpDO1NBbkpZLGdCQUFnQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEFmdGVyVmlld0luaXQsXG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDb21wb25lbnQsXG4gIEVsZW1lbnRSZWYsXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5wdXQsXG4gIE5nWm9uZSxcbiAgT25DaGFuZ2VzLFxuICBPdXRwdXQsXG4gIFZpZXdDaGlsZCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICBDaGFydERhdGEsXG4gIENoYXJ0TGVnZW5kT3B0aW9ucyxcbiAgQ2hhcnRPcHRpb25zLFxuICBDaGFydFR5cGUsXG59IGZyb20gJ2NoYXJ0LmpzJztcblxuZGVjbGFyZSB2YXIgcmVxdWlyZTogYW55O1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICduZ3gtY2hhcnRqcycsXG4gIHRlbXBsYXRlOiBgXG4gIDwhLS0gd3JhcHBpbmcgZGl2IHJlcXVpcmVkIGZvciBoZWlnaHQsIHdpZHRoIHRvIHdvcmsgLS0+XG4gIDxkaXY+XG4gICAgPGNhbnZhc1xuICAgICAgI3JlZlxuICAgICAgW2F0dHIuaGVpZ2h0XT1cImhlaWdodFwiXG4gICAgICBbYXR0ci53aWR0aF09XCJ3aWR0aFwiXG4gICAgICAoY2xpY2spPVwiaGFuZGxlT25DbGljaygkZXZlbnQpXCJcbiAgICA+PC9jYW52YXM+XG4gIDwvZGl2PlxuICBgLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbn0pXG5leHBvcnQgY2xhc3MgQ2hhcnRqc0NvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIE9uQ2hhbmdlcyB7XG4gIGNoYXJ0SW5zdGFuY2U6IGFueTtcbiAgQFZpZXdDaGlsZCgncmVmJywgeyBzdGF0aWM6IHRydWUgfSkgcmVmOiBFbGVtZW50UmVmPEhUTUxDYW52YXNFbGVtZW50PjtcbiAgQE91dHB1dCgpIGNoYXJ0Q2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyPENoYXJ0Q2xpY2tFdmVudD4oKTtcbiAgLyoqIGNoYXJ0IHR5cGUgKi9cbiAgQElucHV0KCkgdHlwZTogQ2hhcnRUeXBlIHwgc3RyaW5nID0gJ2RvdWdobnV0JztcbiAgQElucHV0KCkgZGF0YTogQ2hhcnREYXRhIHwgYW55O1xuICBASW5wdXQoKSBoZWlnaHQgPSAxNTA7XG4gIEBJbnB1dCgpIHdpZHRoID0gMzAwO1xuICBASW5wdXQoKVxuICBsZWdlbmQ6IENoYXJ0TGVnZW5kT3B0aW9ucyB8IGFueSA9IHtcbiAgICBkaXNwbGF5OiB0cnVlLFxuICAgIHBvc2l0aW9uOiAnYm90dG9tJyxcbiAgfTtcbiAgQElucHV0KCkgb3B0aW9uczogQ2hhcnRPcHRpb25zIHwgYW55ID0ge307XG4gIEBJbnB1dCgpIHBsdWdpbnM6IGFueVtdO1xuICBASW5wdXQoKSByZWRyYXcgPSBmYWxzZTtcbiAgQElucHV0KCkgZGF0YXNldEtleVByb3ZpZGVyOiAoeDogYW55KSA9PiBzdHJpbmcgPSBkID0+IGQubGFiZWw7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSB6b25lOiBOZ1pvbmUpIHt9XG5cbiAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgIHRoaXMucmVuZGVyQ2hhcnQoKTtcbiAgfVxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBhbnkpIHtcbiAgICBpZiAoY2hhbmdlcy5maXJzdENoYW5nZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5jaGFydEluc3RhbmNlICYmIHRoaXMucmVkcmF3KSB7XG4gICAgICB0aGlzLmNoYXJ0SW5zdGFuY2UuZGVzdHJveSgpO1xuICAgICAgdGhpcy5yZW5kZXJDaGFydCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUNoYXJ0KCk7XG4gIH1cblxuICB1cGRhdGVDaGFydCgpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy50cmFuc2Zvcm1EYXRhKCk7XG5cbiAgICBpZiAoIXRoaXMuY2hhcnRJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMpIHtcbiAgICAgIC8vIGluIG9yZGVyIHRvIGFsbG93IGZvciB1bml2ZXJzYWwgcmVuZGVyaW5nLCB3ZSBpbXBvcnQgY2hhcnQuanMgcnVudGltZSB3aXRoIGByZXF1aXJlYCB0byBwcmV2ZW50IG5vZGUgZXJyb3JzXG4gICAgICBjb25zdCBDaGFydCA9IHJlcXVpcmUoJ2NoYXJ0LmpzJyk7XG4gICAgICB0aGlzLmNoYXJ0SW5zdGFuY2Uub3B0aW9ucyA9IChDaGFydCBhcyBhbnkpLmhlbHBlcnMuY29uZmlnTWVyZ2UoXG4gICAgICAgIHRoaXMuY2hhcnRJbnN0YW5jZS5vcHRpb25zLFxuICAgICAgICB0aGlzLm9wdGlvbnMsXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIFBpcGUgZGF0YXNldHMgdG8gY2hhcnQgaW5zdGFuY2UgZGF0YXNldHMgZW5hYmxpbmdcbiAgICAvLyBzZWFtbGVzcyB0cmFuc2l0aW9uc1xuICAgIGNvbnN0IGN1cnJlbnREYXRhc2V0czogYW55W10gPVxuICAgICAgKHRoaXMuY2hhcnRJbnN0YW5jZS5jb25maWcuZGF0YSAmJlxuICAgICAgICB0aGlzLmNoYXJ0SW5zdGFuY2UuY29uZmlnLmRhdGEuZGF0YXNldHMpIHx8XG4gICAgICBbXTtcbiAgICBjb25zdCBuZXh0RGF0YXNldHMgPSBkYXRhLmRhdGFzZXRzIHx8IFtdO1xuXG4gICAgY29uc3QgY3VycmVudERhdGFzZXRzSW5kZXhlZCA9IHt9O1xuICAgIGN1cnJlbnREYXRhc2V0cy5mb3JFYWNoKCh4KSA9PiB7XG4gICAgICBjdXJyZW50RGF0YXNldHNJbmRleGVkW3RoaXMuZGF0YXNldEtleVByb3ZpZGVyKHgpXSA9IHg7XG4gICAgfSk7XG5cbiAgICAvLyBXZSBjYW4gc2FmZWx5IHJlcGxhY2UgdGhlIGRhdGFzZXQgYXJyYXksIGFzIGxvbmcgYXMgd2UgcmV0YWluIHRoZSBfbWV0YSBwcm9wZXJ0eVxuICAgIC8vIG9uIGVhY2ggZGF0YXNldC5cbiAgICB0aGlzLmNoYXJ0SW5zdGFuY2UuY29uZmlnLmRhdGEuZGF0YXNldHMgPSBuZXh0RGF0YXNldHMubWFwKG5leHQgPT4ge1xuICAgICAgY29uc3QgY3VycmVudCA9IGN1cnJlbnREYXRhc2V0c0luZGV4ZWRbdGhpcy5kYXRhc2V0S2V5UHJvdmlkZXIobmV4dCldO1xuXG4gICAgICBpZiAoY3VycmVudCAmJiBjdXJyZW50LnR5cGUgPT09IG5leHQudHlwZSkge1xuICAgICAgICAvLyBSZWFzc2lnbiBhbGwgcHJvcGVydGllcyBmcm9tIG5leHRcbiAgICAgICAgZm9yIChjb25zdCBuZXh0UHJvcCBvZiBPYmplY3Qua2V5cyhuZXh0KSkge1xuICAgICAgICAgIC8vIERhdGEgYXJyYXkgY2FuJ3QgYmUgcmVhc3NpZ25lZCBoZXJlLlxuICAgICAgICAgIGlmIChuZXh0UHJvcCAhPT0gJ2RhdGEnKSB7XG4gICAgICAgICAgICBjdXJyZW50W25leHRQcm9wXSA9IG5leHRbbmV4dFByb3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgcHJvcGVydGllcyBmcm9tIGN1cnJlbnQgaWYgdGhleSB3YXMgcmVtb3ZlZCBpbiBuZXh0XG4gICAgICAgIGZvciAoY29uc3QgY3VycmVudFByb3Agb2YgT2JqZWN0LmtleXMoY3VycmVudCkpIHtcbiAgICAgICAgICAvLyBCZSBjYXJlZnVsIHdpdGggX21ldGEgcHJvcGVydHlcbiAgICAgICAgICBpZiAoIW5leHQuaGFzT3duUHJvcGVydHkoY3VycmVudFByb3ApICYmIGN1cnJlbnRQcm9wICE9PSAnX21ldGEnKSB7XG4gICAgICAgICAgICBkZWxldGUgY3VycmVudFtjdXJyZW50UHJvcF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBkYXRhIGFycmF5IG11c3QgYmUgZWRpdGVkIGluIHBsYWNlLiBBcyBjaGFydC5qcyBhZGRzIGxpc3RlbmVycyB0byBpdC5cbiAgICAgICAgY3VycmVudC5kYXRhLnNwbGljZShuZXh0LmRhdGEubGVuZ3RoKTtcbiAgICAgICAgbmV4dC5kYXRhLmZvckVhY2goKHBvaW50LCBwaWQpID0+IHtcbiAgICAgICAgICBjdXJyZW50LmRhdGFbcGlkXSA9IG5leHQuZGF0YVtwaWRdO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH0pO1xuXG4gICAgY29uc3QgeyBkYXRhc2V0cywgLi4ucmVzdCB9ID0gZGF0YTtcblxuICAgIHRoaXMuY2hhcnRJbnN0YW5jZS5jb25maWcuZGF0YSA9IHtcbiAgICAgIC4uLnRoaXMuY2hhcnRJbnN0YW5jZS5jb25maWcuZGF0YSxcbiAgICAgIC4uLnJlc3QsXG4gICAgfTtcblxuICAgIHRoaXMuY2hhcnRJbnN0YW5jZS51cGRhdGUoKTtcbiAgfVxuXG4gIHJlbmRlckNoYXJ0KCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnJlZi5uYXRpdmVFbGVtZW50O1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnRyYW5zZm9ybURhdGEoKTtcblxuICAgIGlmICh0eXBlb2YgdGhpcy5sZWdlbmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zdCBsZWdlbmRPcHRpb25zID0geyAuLi50aGlzLmxlZ2VuZCwgLi4udGhpcy5vcHRpb25zLmxlZ2VuZCB9O1xuICAgICAgdGhpcy5vcHRpb25zLmxlZ2VuZCA9IGxlZ2VuZE9wdGlvbnM7XG4gICAgfVxuXG4gICAgLy8gaW4gb3JkZXIgdG8gYWxsb3cgZm9yIHVuaXZlcnNhbCByZW5kZXJpbmcsIHdlIGltcG9ydCBDb2RlbWlycm9yIHJ1bnRpbWUgd2l0aCBgcmVxdWlyZWAgdG8gcHJldmVudCBub2RlIGVycm9yc1xuICAgIGNvbnN0IENoYXJ0ID0gcmVxdWlyZSgnY2hhcnQuanMnKTtcblxuICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICB0aGlzLmNoYXJ0SW5zdGFuY2UgPSBuZXcgQ2hhcnQobm9kZSwge1xuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9ucyxcbiAgICAgICAgcGx1Z2luczogdGhpcy5wbHVnaW5zLFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICB0cmFuc2Zvcm1EYXRhKCkge1xuICAgIGlmICghdGhpcy5kYXRhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGhpcy5kYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5yZWY7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhKG5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kYXRhO1xuICB9XG5cbiAgaGFuZGxlT25DbGljaygkZXZlbnQ6IEV2ZW50KSB7XG4gICAgdGhpcy5jaGFydENsaWNrLmVtaXQoe1xuICAgICAgZWxlbWVudHM6IHRoaXMuY2hhcnRJbnN0YW5jZS5nZXRFbGVtZW50c0F0RXZlbnQoJGV2ZW50KSxcbiAgICAgIGVsZW1lbnQ6IHRoaXMuY2hhcnRJbnN0YW5jZS5nZXRFbGVtZW50QXRFdmVudCgkZXZlbnQpLFxuICAgICAgZGF0YXNldDogdGhpcy5jaGFydEluc3RhbmNlLmdldERhdGFzZXRBdEV2ZW50KCRldmVudCksXG4gICAgICAkZXZlbnQsXG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDaGFydENsaWNrRXZlbnQge1xuICBlbGVtZW50czogYW55W107XG4gIGVsZW1lbnQ6IGFueTtcbiAgZGF0YXNldDogYW55W107XG4gICRldmVudDogRXZlbnQ7XG59XG4iXX0=